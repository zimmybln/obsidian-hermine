/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => HerminePlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian4 = require("obsidian");

// src/parser.ts
var FUNCTION_KEYS = /* @__PURE__ */ new Set([
  "card-style",
  "karten-stil",
  "cardstyle",
  "style",
  "stil",
  "x-transform",
  "x-transformation",
  "xtransform",
  "y-transform",
  "y-transformation",
  "ytransform"
]);
function unclosedBraces(str) {
  let depth = 0;
  for (const ch of str) {
    if (ch === "{")
      depth++;
    else if (ch === "}")
      depth--;
  }
  return depth;
}
function parseValueList(value) {
  const rangeMatch = value.match(
    /^\[\s*(-?\d+(?:\.\d+)?)\s*\.\.\s*(-?\d+(?:\.\d+)?)\s*(?:,\s*[Ss]tep\s+(\d+(?:\.\d+)?))?\s*\]$/
  );
  if (rangeMatch) {
    const from = parseFloat(rangeMatch[1]);
    const to = parseFloat(rangeMatch[2]);
    const step = rangeMatch[3] ? parseFloat(rangeMatch[3]) : 1;
    if (step <= 0)
      return [String(from)];
    const values = [];
    if (from <= to) {
      for (let v = from; v <= to + step * 1e-9; v += step) {
        values.push(String(Math.round(v * 1e9) / 1e9));
      }
    } else {
      for (let v = from; v >= to - step * 1e-9; v -= step) {
        values.push(String(Math.round(v * 1e9) / 1e9));
      }
    }
    return values;
  }
  return value.split(",").map((s) => s.trim()).filter((s) => s);
}
function parseHermineBlock(content) {
  var _a;
  const lines = content.trim().split("\n");
  const config = {};
  for (let i = 0; i < lines.length; i++) {
    const trimmed = lines[i].trim();
    if (!trimmed || trimmed.startsWith("#") || trimmed.startsWith("//")) {
      continue;
    }
    const colonIndex = trimmed.indexOf(":");
    if (colonIndex === -1)
      continue;
    const key = trimmed.substring(0, colonIndex).trim().toLowerCase();
    let value = trimmed.substring(colonIndex + 1).trim();
    if (FUNCTION_KEYS.has(key) && unclosedBraces(value) > 0) {
      while (i + 1 < lines.length && unclosedBraces(value) > 0) {
        i++;
        value += "\n" + lines[i];
      }
    }
    switch (key) {
      case "title":
      case "titel":
      case "\xFCberschrift":
        config.title = value;
        break;
      case "source":
      case "from":
      case "quelle":
        config.source = value;
        break;
      case "x":
      case "x-axis":
      case "x-achse":
      case "xaxis":
        config.xAxis = value;
        break;
      case "y":
      case "y-axis":
      case "y-achse":
      case "yaxis":
        config.yAxis = value || void 0;
        break;
      case "x-werte":
      case "x-values":
      case "xvalues":
      case "x-options":
        config.xValues = parseValueList(value);
        break;
      case "y-werte":
      case "y-values":
      case "yvalues":
      case "y-options":
        config.yValues = parseValueList(value);
        break;
      case "x-label":
      case "x-beschriftung":
      case "xlabel":
        config.xLabel = value;
        break;
      case "y-label":
      case "y-beschriftung":
      case "ylabel":
        config.yLabel = value;
        break;
      case "x-readonly":
      case "x-gesperrt":
      case "xreadonly":
        config.xReadonly = value.toLowerCase() !== "false" && value !== "0";
        break;
      case "y-readonly":
      case "y-gesperrt":
      case "yreadonly":
        config.yReadonly = value.toLowerCase() !== "false" && value !== "0";
        break;
      case "readonly":
      case "gesperrt":
        {
          const on = value.toLowerCase() !== "false" && value !== "0";
          config.xReadonly = on;
          config.yReadonly = on;
        }
        break;
      case "card-style":
      case "karten-stil":
      case "cardstyle":
      case "style":
      case "stil":
        config.cardStyle = value;
        break;
      case "x-transform":
      case "x-transformation":
      case "xtransform":
        config.xTransform = value;
        break;
      case "y-transform":
      case "y-transformation":
      case "ytransform":
        config.yTransform = value;
        break;
      case "display":
      case "anzeigen":
      case "show":
        config.display = value.split(",").map((s) => s.trim()).filter((s) => s);
        break;
      case "sort":
      case "sortieren":
        const sortParts = value.split(/\s+/);
        config.sort = {
          by: sortParts[0],
          order: ((_a = sortParts[1]) == null ? void 0 : _a.toLowerCase()) === "desc" ? "desc" : "asc"
        };
        break;
      case "where":
      case "filter":
        config.where = value;
        break;
    }
  }
  if (!config.source) {
    throw new Error("Missing required field: source (Quelle)");
  }
  if (!config.xAxis) {
    throw new Error("Missing required field: x-axis (X-Achse)");
  }
  return config;
}

// src/query-engine.ts
var import_obsidian = require("obsidian");

// src/value-transform.ts
function compileTransform(expr) {
  try {
    const trimmed = expr.trim();
    if (!trimmed.startsWith("(")) {
      console.error("Hermine: Transform must be an arrow function, e.g. (v) => ...");
      return null;
    }
    const fn = new Function(`"use strict"; return (${trimmed});`)();
    if (typeof fn !== "function") {
      console.error("Hermine: Transform did not evaluate to a function");
      return null;
    }
    return fn;
  } catch (e) {
    console.error("Hermine: Failed to compile transform:", e);
    return null;
  }
}
function applyTransform(rawValue, transformFn) {
  if (!transformFn)
    return rawValue;
  try {
    return transformFn(rawValue);
  } catch (e) {
    console.error("Hermine: Transform execution error for value", rawValue, e);
    return rawValue;
  }
}
function buildReverseMap(allRawValues, transformFn) {
  const reverseMap = /* @__PURE__ */ new Map();
  for (const raw of allRawValues) {
    const transformed = String(applyTransform(raw, transformFn));
    if (!reverseMap.has(transformed)) {
      reverseMap.set(transformed, []);
    }
    const arr = reverseMap.get(transformed);
    if (!arr.includes(raw)) {
      arr.push(raw);
    }
  }
  return reverseMap;
}

// src/query-engine.ts
var QueryEngine = class {
  constructor(app) {
    this.app = app;
  }
  /**
   * Execute a query and return matching documents
   */
  async execute(config) {
    const result = {
      documents: [],
      xAxisValues: /* @__PURE__ */ new Set(),
      yAxisValues: /* @__PURE__ */ new Set(),
      errors: []
    };
    try {
      const files = this.getSourceFiles(config.source);
      const xTransformFn = config.xTransform ? compileTransform(config.xTransform) : null;
      const yTransformFn = config.yTransform ? compileTransform(config.yTransform) : null;
      const xRawValues = [];
      const yRawValues = [];
      for (const file of files) {
        const docData = await this.getDocumentData(file);
        if (docData) {
          if (config.where && !this.evaluateFilter(docData, config.where)) {
            continue;
          }
          result.documents.push(docData);
          const xValue = this.getPropertyValue(docData.properties, config.xAxis);
          if (xValue !== void 0 && xValue !== null) {
            if (Array.isArray(xValue)) {
              xValue.forEach((v) => {
                xRawValues.push(v);
                result.xAxisValues.add(applyTransform(v, xTransformFn));
              });
            } else {
              xRawValues.push(xValue);
              result.xAxisValues.add(applyTransform(xValue, xTransformFn));
            }
          }
          if (config.yAxis) {
            const yValue = this.getPropertyValue(docData.properties, config.yAxis);
            if (yValue !== void 0 && yValue !== null) {
              if (Array.isArray(yValue)) {
                yValue.forEach((v) => {
                  yRawValues.push(v);
                  result.yAxisValues.add(applyTransform(v, yTransformFn));
                });
              } else {
                yRawValues.push(yValue);
                result.yAxisValues.add(applyTransform(yValue, yTransformFn));
              }
            }
          }
        }
      }
      result.xAxisRawValues = xRawValues;
      result.yAxisRawValues = yRawValues;
      if (config.sort) {
        result.documents = this.sortDocuments(result.documents, config.sort);
      }
    } catch (error) {
      result.errors.push(`Query error: ${error.message}`);
    }
    return result;
  }
  /**
   * Get files matching the source specification
   */
  getSourceFiles(source) {
    const files = [];
    const vault = this.app.vault;
    if (source === "all" || source === "alle" || source === "*") {
      return vault.getMarkdownFiles();
    }
    if (source.startsWith("#")) {
      const tag = source.toLowerCase();
      for (const file of vault.getMarkdownFiles()) {
        const cache = this.app.metadataCache.getFileCache(file);
        if (cache) {
          const tags = (0, import_obsidian.getAllTags)(cache) || [];
          if (tags.some((t) => t.toLowerCase() === tag || t.toLowerCase().startsWith(tag + "/"))) {
            files.push(file);
          }
        }
      }
      return files;
    }
    if (source.startsWith('"') && source.endsWith('"')) {
      const folderPath = source.slice(1, -1);
      return this.getFilesFromFolder(folderPath);
    }
    return this.getFilesFromFolder(source);
  }
  /**
   * Get all markdown files from a folder (recursive)
   */
  getFilesFromFolder(folderPath) {
    const files = [];
    const folder = this.app.vault.getAbstractFileByPath(folderPath);
    if (folder instanceof import_obsidian.TFolder) {
      this.collectFilesRecursive(folder, files);
    }
    return files;
  }
  /**
   * Recursively collect markdown files from a folder
   */
  collectFilesRecursive(folder, files) {
    for (const child of folder.children) {
      if (child instanceof import_obsidian.TFile && child.extension === "md") {
        files.push(child);
      } else if (child instanceof import_obsidian.TFolder) {
        this.collectFilesRecursive(child, files);
      }
    }
  }
  /**
   * Get document data including frontmatter properties
   */
  async getDocumentData(file) {
    const cache = this.app.metadataCache.getFileCache(file);
    if (!cache) {
      return null;
    }
    const properties = {};
    if (cache.frontmatter) {
      Object.assign(properties, cache.frontmatter);
    }
    properties["file.name"] = file.basename;
    properties["file.path"] = file.path;
    properties["file.ctime"] = file.stat.ctime;
    properties["file.mtime"] = file.stat.mtime;
    properties["file.size"] = file.stat.size;
    const tags = (0, import_obsidian.getAllTags)(cache) || [];
    properties["file.tags"] = tags;
    return {
      file,
      path: file.path,
      name: file.basename,
      properties
    };
  }
  /**
   * Get a property value, supporting nested paths like "author.name"
   */
  getPropertyValue(properties, path) {
    const parts = path.split(".");
    let value = properties;
    for (const part of parts) {
      if (value === null || value === void 0) {
        return void 0;
      }
      value = value[part];
    }
    return value;
  }
  /**
   * Evaluate a simple filter expression
   * Supports: property = value, property != value, property contains value
   */
  evaluateFilter(doc, filter) {
    const containsMatch = filter.match(/(\S+)\s+contains\s+"([^"]+)"/i);
    if (containsMatch) {
      const [, prop, value] = containsMatch;
      const propValue = this.getPropertyValue(doc.properties, prop);
      if (Array.isArray(propValue)) {
        return propValue.some((v) => String(v).includes(value));
      }
      return String(propValue || "").includes(value);
    }
    const equalsMatch = filter.match(/(\S+)\s*(!?=)\s*"([^"]+)"/);
    if (equalsMatch) {
      const [, prop, operator, value] = equalsMatch;
      const propValue = this.getPropertyValue(doc.properties, prop);
      const isEqual = String(propValue) === value;
      return operator === "!=" ? !isEqual : isEqual;
    }
    return true;
  }
  /**
   * Sort documents by a property
   */
  sortDocuments(documents, sort) {
    return [...documents].sort((a, b) => {
      const aVal = this.getPropertyValue(a.properties, sort.by);
      const bVal = this.getPropertyValue(b.properties, sort.by);
      let comparison = 0;
      if (aVal < bVal)
        comparison = -1;
      if (aVal > bVal)
        comparison = 1;
      return sort.order === "desc" ? -comparison : comparison;
    });
  }
};

// src/matrix-renderer.ts
var import_obsidian3 = require("obsidian");

// src/frontmatter-updater.ts
var FrontmatterUpdater = class {
  constructor(app) {
    this.app = app;
  }
  /**
   * Update a single property in a file's frontmatter
   */
  async updateProperty(file, propertyName, newValue) {
    const content = await this.app.vault.read(file);
    const updatedContent = this.updateFrontmatterProperty(content, propertyName, newValue);
    await this.app.vault.modify(file, updatedContent);
  }
  /**
   * Update multiple properties in a file's frontmatter
   */
  async updateProperties(file, updates) {
    let content = await this.app.vault.read(file);
    for (const [propertyName, newValue] of Object.entries(updates)) {
      content = this.updateFrontmatterProperty(content, propertyName, newValue);
    }
    await this.app.vault.modify(file, content);
  }
  /**
   * Update a property in the frontmatter content
   */
  updateFrontmatterProperty(content, propertyName, newValue) {
    const frontmatterRegex = /^---\n([\s\S]*?)\n---/;
    const match = content.match(frontmatterRegex);
    if (!match) {
      const formattedValue = this.formatYamlValue(newValue);
      return `---
${propertyName}: ${formattedValue}
---

${content}`;
    }
    const frontmatterContent = match[1];
    const lines = frontmatterContent.split("\n");
    let propertyFound = false;
    let inMultilineValue = false;
    let currentIndent = 0;
    const updatedLines = lines.map((line, index) => {
      const lineIndent = line.search(/\S/);
      if (lineIndent === -1)
        return line;
      if (inMultilineValue) {
        if (lineIndent > currentIndent || line.trim().startsWith("-")) {
          return null;
        } else {
          inMultilineValue = false;
        }
      }
      const propMatch = line.match(/^(\s*)([^:]+):\s*(.*)/);
      if (propMatch) {
        const [, indent, name, value] = propMatch;
        if (name.trim() === propertyName) {
          propertyFound = true;
          const formattedValue = this.formatYamlValue(newValue);
          if (Array.isArray(newValue)) {
            inMultilineValue = true;
            currentIndent = indent.length;
            if (newValue.length === 0) {
              return `${indent}${propertyName}: []`;
            }
            const listItems = newValue.map((v) => `${indent}  - ${this.formatYamlValue(v)}`).join("\n");
            return `${indent}${propertyName}:
${listItems}`;
          }
          return `${indent}${propertyName}: ${formattedValue}`;
        }
      }
      return line;
    }).filter((line) => line !== null);
    if (!propertyFound) {
      const formattedValue = this.formatYamlValue(newValue);
      if (Array.isArray(newValue) && newValue.length > 0) {
        const listItems = newValue.map((v) => `  - ${this.formatYamlValue(v)}`).join("\n");
        updatedLines.push(`${propertyName}:
${listItems}`);
      } else {
        updatedLines.push(`${propertyName}: ${formattedValue}`);
      }
    }
    const updatedFrontmatter = updatedLines.join("\n");
    return content.replace(frontmatterRegex, `---
${updatedFrontmatter}
---`);
  }
  /**
   * Format a value for YAML
   */
  formatYamlValue(value) {
    if (value === null || value === void 0) {
      return "";
    }
    if (typeof value === "boolean") {
      return value ? "true" : "false";
    }
    if (typeof value === "number") {
      return String(value);
    }
    if (typeof value === "string") {
      if (value === "" || value.includes(":") || value.includes("#") || value.includes("'") || value.includes('"') || value.includes("\n") || value.startsWith(" ") || value.endsWith(" ") || /^[0-9]/.test(value) || ["true", "false", "null", "yes", "no"].includes(value.toLowerCase())) {
        return `"${value.replace(/"/g, '\\"')}"`;
      }
      return value;
    }
    if (Array.isArray(value)) {
      if (value.length === 0) {
        return "[]";
      }
      return `[${value.map((v) => this.formatYamlValue(v)).join(", ")}]`;
    }
    if (typeof value === "object") {
      const entries = Object.entries(value).map(([k, v]) => `${k}: ${this.formatYamlValue(v)}`).join(", ");
      return `{${entries}}`;
    }
    return String(value);
  }
  /**
   * Parse a value from string input to appropriate type
   */
  parseValue(input, originalValue) {
    const trimmed = input.trim();
    if (typeof originalValue === "boolean") {
      return trimmed.toLowerCase() === "true" || trimmed === "1" || trimmed.toLowerCase() === "yes";
    }
    if (typeof originalValue === "number") {
      const num = parseFloat(trimmed);
      return isNaN(num) ? trimmed : num;
    }
    if (Array.isArray(originalValue)) {
      if (trimmed.startsWith("[") && trimmed.endsWith("]")) {
        try {
          return JSON.parse(trimmed);
        } catch (e) {
        }
      }
      return trimmed.split(",").map((s) => s.trim()).filter((s) => s);
    }
    if (trimmed.toLowerCase() === "true" || trimmed.toLowerCase() === "yes") {
      return true;
    }
    if (trimmed.toLowerCase() === "false" || trimmed.toLowerCase() === "no") {
      return false;
    }
    const numValue = parseFloat(trimmed);
    if (!isNaN(numValue) && String(numValue) === trimmed) {
      return numValue;
    }
    return trimmed;
  }
};

// src/value-picker-modal.ts
var import_obsidian2 = require("obsidian");
var ValuePickerModal = class extends import_obsidian2.Modal {
  constructor(app, axisName, groupLabel, existingValues, transformFn, onChoose) {
    super(app);
    this.axisName = axisName;
    this.groupLabel = groupLabel;
    this.existingValues = existingValues;
    this.transformFn = transformFn;
    this.onChoose = onChoose;
    this.resolved = false;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.addClass("hermine-value-picker-modal");
    contentEl.createEl("h3", {
      text: `Wert f\xFCr "${this.axisName}" w\xE4hlen`
    });
    contentEl.createEl("p", {
      cls: "hermine-picker-info",
      text: `Zielgruppe: ${this.groupLabel}`
    });
    const inputContainer = contentEl.createDiv({ cls: "hermine-picker-input-container" });
    const input = inputContainer.createEl("input", {
      cls: "hermine-picker-input",
      type: "text",
      placeholder: "Wert eingeben..."
    });
    input.focus();
    const validation = contentEl.createDiv({ cls: "hermine-picker-validation" });
    if (this.existingValues.length > 0) {
      const suggestionsContainer = contentEl.createDiv({ cls: "hermine-picker-suggestions" });
      suggestionsContainer.createEl("span", {
        cls: "hermine-picker-suggestions-label",
        text: "Vorhandene Werte:"
      });
      const suggestionsWrapper = suggestionsContainer.createDiv({ cls: "hermine-picker-suggestions-list" });
      for (const val of this.existingValues.sort()) {
        const chip = suggestionsWrapper.createEl("button", {
          cls: "hermine-picker-chip",
          text: String(val)
        });
        chip.addEventListener("click", () => {
          input.value = String(val);
          input.dispatchEvent(new Event("input"));
        });
      }
    }
    const buttonContainer = contentEl.createDiv({ cls: "hermine-picker-buttons" });
    const confirmBtn = buttonContainer.createEl("button", {
      cls: "hermine-picker-confirm mod-cta",
      text: "\xDCbernehmen"
    });
    confirmBtn.disabled = true;
    const cancelBtn = buttonContainer.createEl("button", {
      cls: "hermine-picker-cancel",
      text: "Abbrechen"
    });
    const validateInput = () => {
      const raw = input.value.trim();
      if (!raw) {
        validation.textContent = "";
        validation.className = "hermine-picker-validation";
        confirmBtn.disabled = true;
        return;
      }
      const parsed = this.parseInputValue(raw);
      const transformed = String(applyTransform(parsed, this.transformFn));
      if (transformed === this.groupLabel) {
        validation.textContent = `\u2713 Wert ${raw} \u2192 Gruppe "${transformed}"`;
        validation.className = "hermine-picker-validation hermine-picker-valid";
        confirmBtn.disabled = false;
      } else {
        validation.textContent = `\u2717 Wert ${raw} geh\xF6rt zu Gruppe "${transformed}", nicht "${this.groupLabel}"`;
        validation.className = "hermine-picker-validation hermine-picker-invalid";
        confirmBtn.disabled = true;
      }
    };
    input.addEventListener("input", validateInput);
    const confirm = () => {
      if (confirmBtn.disabled)
        return;
      this.resolved = true;
      const parsed = this.parseInputValue(input.value.trim());
      this.onChoose(parsed);
      this.close();
    };
    confirmBtn.addEventListener("click", confirm);
    input.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        confirm();
      } else if (e.key === "Escape") {
        this.close();
      }
    });
    cancelBtn.addEventListener("click", () => {
      this.close();
    });
  }
  onClose() {
    if (!this.resolved) {
      this.onChoose(null);
    }
    this.contentEl.empty();
  }
  /**
   * Parse user input into appropriate type (number if possible, otherwise string)
   */
  parseInputValue(input) {
    const num = parseFloat(input);
    if (!isNaN(num) && String(num) === input) {
      return num;
    }
    const int = parseInt(input, 10);
    if (!isNaN(int) && String(int) === input) {
      return int;
    }
    return input;
  }
};

// src/matrix-renderer.ts
var _MatrixRenderer = class extends import_obsidian3.MarkdownRenderChild {
  constructor(containerEl, app, config, result, onRefresh) {
    super(containerEl);
    this.app = app;
    this.config = config;
    this.result = result;
    this.onRefresh = onRefresh;
    this.previewEl = null;
    this.previewTimeout = null;
    this.currentDragDoc = null;
    this.zoomLevel = 100;
    this.boardEl = null;
    this.zoomDisplay = null;
    // Transform support
    this.xTransformFn = null;
    this.yTransformFn = null;
    this.xReverseMap = null;
    this.yReverseMap = null;
    // Card style function
    this.cardStyleFn = null;
    this.updater = new FrontmatterUpdater(app);
  }
  onload() {
    if (this.config.xTransform) {
      this.xTransformFn = compileTransform(this.config.xTransform);
      if (this.xTransformFn && this.result.xAxisRawValues) {
        this.xReverseMap = buildReverseMap(this.result.xAxisRawValues, this.xTransformFn);
      }
    }
    if (this.config.yTransform) {
      this.yTransformFn = compileTransform(this.config.yTransform);
      if (this.yTransformFn && this.result.yAxisRawValues) {
        this.yReverseMap = buildReverseMap(this.result.yAxisRawValues, this.yTransformFn);
      }
    }
    if (this.config.cardStyle) {
      this.cardStyleFn = compileTransform(this.config.cardStyle);
    }
    this.render();
  }
  onunload() {
    this.hidePreview();
  }
  /**
   * Main render method
   */
  render() {
    this.containerEl.empty();
    this.containerEl.addClass("hermine-container");
    if (this.config.title) {
      this.containerEl.createEl("h3", {
        cls: "hermine-title",
        text: this.config.title
      });
    }
    if (this.result.errors.length > 0) {
      this.renderErrors();
      return;
    }
    if (this.result.documents.length === 0) {
      this.renderEmptyState();
      return;
    }
    if (this.config.yAxis) {
      this.renderMatrix();
    } else {
      this.renderTable();
    }
  }
  /**
   * Render error messages
   */
  renderErrors() {
    const errorContainer = this.containerEl.createDiv({ cls: "hermine-errors" });
    for (const error of this.result.errors) {
      errorContainer.createDiv({ cls: "hermine-error", text: error });
    }
  }
  /**
   * Render empty state message
   */
  renderEmptyState() {
    this.containerEl.createDiv({
      cls: "hermine-empty",
      text: "Keine Dokumente gefunden."
    });
  }
  /**
   * Render a simple table (X-axis only)
   */
  renderTable() {
    const table = this.containerEl.createEl("table", { cls: "hermine-table" });
    const thead = table.createEl("thead");
    const headerRow = thead.createEl("tr");
    headerRow.createEl("th", { text: "Dokument" });
    headerRow.createEl("th", { text: this.config.xAxis });
    if (this.config.display) {
      for (const prop of this.config.display) {
        headerRow.createEl("th", { text: prop });
      }
    }
    const tbody = table.createEl("tbody");
    for (const doc of this.result.documents) {
      const row = tbody.createEl("tr");
      const nameCell = row.createEl("td", { cls: "hermine-cell-name" });
      const link = nameCell.createEl("a", {
        cls: "internal-link",
        text: doc.name
      });
      link.addEventListener("click", (e) => {
        e.preventDefault();
        this.app.workspace.openLinkText(doc.path, "");
      });
      const xValue = this.getPropertyValue(doc.properties, this.config.xAxis);
      const xCell = row.createEl("td", { cls: "hermine-cell-editable" });
      this.renderEditableCell(xCell, doc, this.config.xAxis, xValue);
      if (this.config.display) {
        for (const prop of this.config.display) {
          const value = this.getPropertyValue(doc.properties, prop);
          const cell = row.createEl("td", { cls: "hermine-cell-editable" });
          this.renderEditableCell(cell, doc, prop, value);
        }
      }
    }
    this.renderRefreshButton();
  }
  /**
   * Render a matrix view (X and Y axes) as a visual board with draggable cards
   */
  renderMatrix() {
    const xValues = this.config.xValues ? this.config.xValues : Array.from(this.result.xAxisValues).sort();
    const yValues = this.config.yValues ? this.config.yValues : Array.from(this.result.yAxisValues).sort();
    const boardLayout = this.containerEl.createDiv({ cls: "hermine-board-layout" });
    if (this.config.yLabel) {
      const yLabelEl = boardLayout.createDiv({ cls: "hermine-axis-label-y" });
      yLabelEl.createSpan({ text: this.config.yLabel });
    }
    const zoomWrapper = boardLayout.createDiv({ cls: "hermine-zoom-wrapper" });
    zoomWrapper.addEventListener("wheel", (e) => {
      if (e.ctrlKey) {
        e.preventDefault();
        if (e.deltaY < 0) {
          this.zoomIn();
        } else {
          this.zoomOut();
        }
      }
    }, { passive: false });
    const board = zoomWrapper.createDiv({ cls: "hermine-board" });
    this.boardEl = board;
    board.style.gridTemplateColumns = `auto repeat(${xValues.length}, 1fr)`;
    this.applyZoom();
    const corner = board.createDiv({ cls: "hermine-board-corner" });
    for (const xVal of xValues) {
      const xHeader = board.createDiv({ cls: "hermine-board-header-x" });
      xHeader.createSpan({ text: String(xVal) });
    }
    for (const yVal of yValues) {
      const yHeader = board.createDiv({ cls: "hermine-board-header-y" });
      yHeader.createSpan({ text: String(yVal) });
      for (const xVal of xValues) {
        const cell = board.createDiv({ cls: "hermine-board-cell" });
        cell.dataset.xValue = String(xVal);
        cell.dataset.yValue = String(yVal);
        this.setupDropZone(cell, xVal, yVal);
        const matchingDocs = this.result.documents.filter((doc) => {
          const rawX = this.getPropertyValue(doc.properties, this.config.xAxis);
          const rawY = this.getPropertyValue(doc.properties, this.config.yAxis);
          const xMatch = Array.isArray(rawX) ? rawX.some((v) => String(applyTransform(v, this.xTransformFn)) === String(xVal)) : String(applyTransform(rawX, this.xTransformFn)) === String(xVal);
          const yMatch = Array.isArray(rawY) ? rawY.some((v) => String(applyTransform(v, this.yTransformFn)) === String(yVal)) : String(applyTransform(rawY, this.yTransformFn)) === String(yVal);
          return xMatch && yMatch;
        });
        if (matchingDocs.length > 0) {
          const dotsContainer = cell.createDiv({ cls: "hermine-board-items" });
          for (const doc of matchingDocs) {
            this.renderDocumentCard(dotsContainer, doc);
          }
        }
      }
    }
    if (this.config.xLabel) {
      board.createDiv();
      const xLabelEl = board.createDiv({ cls: "hermine-axis-label-x" });
      xLabelEl.style.gridColumn = `span ${xValues.length}`;
      xLabelEl.createSpan({ text: this.config.xLabel });
    }
    this.renderUnassigned(xValues, yValues);
    this.renderRefreshButton();
  }
  /**
   * Render a document as a draggable card for the board view
   */
  renderDocumentCard(container, doc) {
    const card = container.createDiv({ cls: "hermine-card" });
    const cardStyle = this.evaluateCardStyle(doc);
    const colorBar = card.createDiv({ cls: "hermine-card-color" });
    colorBar.style.backgroundColor = cardStyle.color || this.getDocumentColor(doc.name);
    if (cardStyle.background) {
      card.style.backgroundColor = cardStyle.background;
    }
    if (cardStyle.border) {
      card.style.borderLeft = `3px solid ${cardStyle.border}`;
    }
    const content = card.createDiv({ cls: "hermine-card-content" });
    const titleSpan = content.createSpan({ cls: "hermine-card-title", text: doc.name });
    if (cardStyle.textColor) {
      titleSpan.style.color = cardStyle.textColor;
    }
    card.dataset.docPath = doc.path;
    const fullyReadonly = this.config.xReadonly && this.config.yReadonly;
    card.draggable = !fullyReadonly;
    if (fullyReadonly) {
      card.style.cursor = "pointer";
    }
    card.addEventListener("dragstart", (e) => {
      var _a;
      if (fullyReadonly) {
        e.preventDefault();
        return;
      }
      this.currentDragDoc = doc;
      card.addClass("hermine-card-dragging");
      (_a = e.dataTransfer) == null ? void 0 : _a.setData("text/plain", doc.path);
      const docX = this.getPropertyValue(doc.properties, this.config.xAxis);
      const docY = this.config.yAxis ? this.getPropertyValue(doc.properties, this.config.yAxis) : void 0;
      const docXStr = String(applyTransform(docX, this.xTransformFn));
      const docYStr = docY !== void 0 ? String(applyTransform(docY, this.yTransformFn)) : void 0;
      this.containerEl.querySelectorAll(".hermine-board-cell").forEach((cell) => {
        const el = cell;
        const cellX = el.dataset.xValue;
        const cellY = el.dataset.yValue;
        const xAllowed = !this.config.xReadonly || cellX === docXStr;
        const yAllowed = !this.config.yReadonly || cellY === docYStr;
        if (xAllowed && yAllowed) {
          el.addClass("hermine-drop-zone-active");
        }
      });
    });
    card.addEventListener("dragend", () => {
      this.currentDragDoc = null;
      card.removeClass("hermine-card-dragging");
      this.containerEl.querySelectorAll(".hermine-board-cell").forEach((cell) => {
        cell.removeClass("hermine-drop-zone-active");
        cell.removeClass("hermine-drop-zone-hover");
      });
    });
    card.addEventListener("click", (e) => {
      e.preventDefault();
      this.app.workspace.openLinkText(doc.path, "");
    });
    card.addEventListener("mouseenter", (e) => {
      this.schedulePreview(doc, e);
    });
    card.addEventListener("mouseleave", () => {
      this.hidePreview();
    });
    card.addEventListener("mousemove", (e) => {
      if (this.previewEl) {
        this.positionPreview(e);
      }
    });
  }
  /**
   * Render a document as a draggable dot with title (for table view)
   */
  renderDocumentDot(container, doc) {
    const wrapper = container.createDiv({ cls: "hermine-dot-wrapper" });
    const dot = wrapper.createDiv({ cls: "hermine-dot" });
    const color = this.getDocumentColor(doc.name);
    dot.style.backgroundColor = color;
    const title = wrapper.createSpan({ cls: "hermine-dot-title", text: doc.name });
    wrapper.dataset.docPath = doc.path;
    wrapper.draggable = true;
    wrapper.addEventListener("dragstart", (e) => {
      var _a;
      this.currentDragDoc = doc;
      wrapper.addClass("hermine-dot-dragging");
      (_a = e.dataTransfer) == null ? void 0 : _a.setData("text/plain", doc.path);
      this.containerEl.querySelectorAll(".hermine-matrix-cell").forEach((cell) => {
        cell.addClass("hermine-drop-zone-active");
      });
    });
    wrapper.addEventListener("dragend", () => {
      this.currentDragDoc = null;
      wrapper.removeClass("hermine-dot-dragging");
      this.containerEl.querySelectorAll(".hermine-matrix-cell").forEach((cell) => {
        cell.removeClass("hermine-drop-zone-active");
        cell.removeClass("hermine-drop-zone-hover");
      });
    });
    wrapper.addEventListener("click", (e) => {
      e.preventDefault();
      this.app.workspace.openLinkText(doc.path, "");
    });
    wrapper.addEventListener("mouseenter", (e) => {
      this.schedulePreview(doc, e);
    });
    wrapper.addEventListener("mouseleave", () => {
      this.hidePreview();
    });
    wrapper.addEventListener("mousemove", (e) => {
      if (this.previewEl) {
        this.positionPreview(e);
      }
    });
  }
  /**
   * Setup a cell as a drop zone
   */
  setupDropZone(cell, xVal, yVal) {
    cell.addEventListener("dragover", (e) => {
      if (!cell.hasClass("hermine-drop-zone-active"))
        return;
      e.preventDefault();
      cell.addClass("hermine-drop-zone-hover");
    });
    cell.addEventListener("dragleave", () => {
      cell.removeClass("hermine-drop-zone-hover");
    });
    cell.addEventListener("drop", async (e) => {
      if (!cell.hasClass("hermine-drop-zone-active"))
        return;
      e.preventDefault();
      cell.removeClass("hermine-drop-zone-hover");
      if (!this.currentDragDoc)
        return;
      const doc = this.currentDragDoc;
      try {
        const updates = {};
        if (!this.config.xReadonly) {
          const xWriteValue = await this.resolveDropValue(
            xVal,
            this.xTransformFn,
            this.xReverseMap,
            this.config.xAxis
          );
          if (xWriteValue === null)
            return;
          updates[this.config.xAxis] = xWriteValue;
        }
        if (!this.config.yReadonly) {
          const yWriteValue = await this.resolveDropValue(
            yVal,
            this.yTransformFn,
            this.yReverseMap,
            this.config.yAxis
          );
          if (yWriteValue === null)
            return;
          updates[this.config.yAxis] = yWriteValue;
        }
        if (Object.keys(updates).length === 0)
          return;
        await this.updater.updateProperties(doc.file, updates);
        this.refreshOnCacheUpdate(doc.file);
      } catch (error) {
        console.error("Failed to update document position:", error);
      }
    });
  }
  /**
   * Wait for Obsidian's metadata cache to update for a specific file,
   * then trigger a full refresh so card-style and positions are correct.
   */
  refreshOnCacheUpdate(file) {
    const maxWait = 2e3;
    const handler = (changedFile) => {
      if (changedFile.path === file.path) {
        cleanup();
        this.onRefresh();
      }
    };
    const timeout = setTimeout(() => {
      cleanup();
      this.onRefresh();
    }, maxWait);
    const cleanup = () => {
      this.app.metadataCache.off("changed", handler);
      clearTimeout(timeout);
    };
    this.app.metadataCache.on("changed", handler);
  }
  /**
   * Resolve the raw value to write when dropping into a cell.
   * If a transform is active, opens a value picker modal.
   * Returns null if the user cancels.
   */
  resolveDropValue(cellDisplayValue, transformFn, reverseMap, axisName) {
    return new Promise((resolve) => {
      if (!transformFn) {
        resolve(cellDisplayValue);
        return;
      }
      const candidates = (reverseMap == null ? void 0 : reverseMap.get(String(cellDisplayValue))) || [];
      const modal = new ValuePickerModal(
        this.app,
        axisName,
        String(cellDisplayValue),
        candidates,
        transformFn,
        (chosenValue) => {
          resolve(chosenValue);
        }
      );
      modal.open();
    });
  }
  /**
   * Schedule showing the preview after a short delay
   */
  schedulePreview(doc, event) {
    this.hidePreview();
    this.previewTimeout = setTimeout(async () => {
      await this.showPreview(doc, event);
    }, 300);
  }
  /**
   * Show the document preview popup
   */
  async showPreview(doc, event) {
    this.hidePreview();
    this.previewEl = document.body.createDiv({ cls: "hermine-preview" });
    const header = this.previewEl.createDiv({ cls: "hermine-preview-header" });
    header.createSpan({ text: doc.name, cls: "hermine-preview-title" });
    const content = this.previewEl.createDiv({ cls: "hermine-preview-content" });
    try {
      const fileContent = await this.app.vault.read(doc.file);
      const contentWithoutFrontmatter = fileContent.replace(/^---[\s\S]*?---\n?/, "");
      const previewContent = contentWithoutFrontmatter.slice(0, 1e3);
      const truncated = contentWithoutFrontmatter.length > 1e3;
      await import_obsidian3.MarkdownRenderer.render(
        this.app,
        previewContent + (truncated ? "\n\n*...*" : ""),
        content,
        doc.path,
        new import_obsidian3.Component()
      );
    } catch (error) {
      content.createSpan({ text: "Vorschau nicht verf\xFCgbar", cls: "hermine-preview-error" });
    }
    this.positionPreview(event);
  }
  /**
   * Position the preview near the cursor
   */
  positionPreview(event) {
    if (!this.previewEl)
      return;
    const padding = 15;
    const maxWidth = 400;
    const maxHeight = 300;
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;
    let left = event.clientX + padding;
    let top = event.clientY + padding;
    if (left + maxWidth > viewportWidth) {
      left = event.clientX - maxWidth - padding;
    }
    if (top + maxHeight > viewportHeight) {
      top = event.clientY - maxHeight - padding;
    }
    left = Math.max(padding, left);
    top = Math.max(padding, top);
    this.previewEl.style.left = `${left}px`;
    this.previewEl.style.top = `${top}px`;
  }
  /**
   * Hide the preview popup
   */
  hidePreview() {
    if (this.previewTimeout) {
      clearTimeout(this.previewTimeout);
      this.previewTimeout = null;
    }
    if (this.previewEl) {
      this.previewEl.remove();
      this.previewEl = null;
    }
  }
  /**
   * Evaluate the cardStyle function for a document.
   * Returns a normalized style object.
   *
   * The user function receives all document properties and may return:
   *   - a string  → used as the color bar color
   *   - an object  → { color?, background?, border?, textColor? }
   *   - null/undefined → default styling
   */
  evaluateCardStyle(doc) {
    var _a, _b, _c, _d, _e;
    if (!this.cardStyleFn)
      return {};
    try {
      const result = this.cardStyleFn(doc.properties);
      if (!result)
        return {};
      if (typeof result === "string") {
        return { color: result };
      }
      if (typeof result === "object") {
        return {
          color: (_a = result.color) != null ? _a : result.farbe,
          background: (_b = result.background) != null ? _b : result.hintergrund,
          border: (_c = result.border) != null ? _c : result.rahmen,
          textColor: (_e = (_d = result.textColor) != null ? _d : result.textFarbe) != null ? _e : result.text
        };
      }
    } catch (e) {
      console.error("Hermine: card-style evaluation error for", doc.name, e);
    }
    return {};
  }
  /**
   * Generate a consistent color for a document based on its name
   */
  getDocumentColor(name) {
    let hash = 0;
    for (let i = 0; i < name.length; i++) {
      hash = name.charCodeAt(i) + ((hash << 5) - hash);
    }
    const hue = Math.abs(hash) % 360;
    return `hsl(${hue}, 70%, 60%)`;
  }
  /**
   * Render unassigned documents that couldn't be placed in the matrix
   */
  renderUnassigned(xValues, yValues) {
    const unassigned = this.result.documents.filter((doc) => {
      const rawX = this.getPropertyValue(doc.properties, this.config.xAxis);
      const rawY = this.getPropertyValue(doc.properties, this.config.yAxis);
      if (rawX === void 0 || rawX === null || rawX === "" || rawY === void 0 || rawY === null || rawY === "") {
        return true;
      }
      const xMatches = xValues.some(
        (xVal) => Array.isArray(rawX) ? rawX.some((v) => String(applyTransform(v, this.xTransformFn)) === String(xVal)) : String(applyTransform(rawX, this.xTransformFn)) === String(xVal)
      );
      const yMatches = yValues.some(
        (yVal) => Array.isArray(rawY) ? rawY.some((v) => String(applyTransform(v, this.yTransformFn)) === String(yVal)) : String(applyTransform(rawY, this.yTransformFn)) === String(yVal)
      );
      return !xMatches || !yMatches;
    });
    if (unassigned.length === 0)
      return;
    const section = this.containerEl.createDiv({ cls: "hermine-unassigned" });
    section.createEl("strong", { text: "Nicht zugeordnet:" });
    const items = section.createDiv({ cls: "hermine-unassigned-items" });
    for (const doc of unassigned) {
      this.renderDocumentCard(items, doc);
    }
  }
  /**
   * Render an editable cell
   */
  renderEditableCell(container, doc, propertyName, value, compact = false) {
    const displayValue = this.formatDisplayValue(value);
    const wrapper = container.createDiv({ cls: "hermine-editable-wrapper" });
    const display = wrapper.createSpan({
      cls: "hermine-value-display",
      text: displayValue
    });
    const input = wrapper.createEl("input", {
      cls: "hermine-value-input",
      type: "text",
      value: displayValue
    });
    input.style.display = "none";
    if (compact) {
      const label = wrapper.createSpan({
        cls: "hermine-prop-label",
        text: `${propertyName}: `
      });
      wrapper.insertBefore(label, display);
    }
    const editBtn = wrapper.createEl("button", { cls: "hermine-edit-btn" });
    (0, import_obsidian3.setIcon)(editBtn, "pencil");
    editBtn.title = "Bearbeiten";
    const saveBtn = wrapper.createEl("button", { cls: "hermine-save-btn" });
    (0, import_obsidian3.setIcon)(saveBtn, "check");
    saveBtn.title = "Speichern";
    saveBtn.style.display = "none";
    const cancelBtn = wrapper.createEl("button", { cls: "hermine-cancel-btn" });
    (0, import_obsidian3.setIcon)(cancelBtn, "x");
    cancelBtn.title = "Abbrechen";
    cancelBtn.style.display = "none";
    const enterEditMode = () => {
      display.style.display = "none";
      editBtn.style.display = "none";
      input.style.display = "";
      saveBtn.style.display = "";
      cancelBtn.style.display = "";
      input.focus();
      input.select();
    };
    const exitEditMode = () => {
      display.style.display = "";
      editBtn.style.display = "";
      input.style.display = "none";
      saveBtn.style.display = "none";
      cancelBtn.style.display = "none";
      input.value = displayValue;
    };
    const saveValue = async () => {
      const newValue = this.updater.parseValue(input.value, value);
      if (newValue !== value) {
        try {
          await this.updater.updateProperty(doc.file, propertyName, newValue);
          display.textContent = this.formatDisplayValue(newValue);
          this.refreshOnCacheUpdate(doc.file);
        } catch (error) {
          console.error("Failed to update property:", error);
          container.addClass("hermine-error-flash");
          setTimeout(() => container.removeClass("hermine-error-flash"), 500);
        }
      }
      exitEditMode();
    };
    editBtn.addEventListener("click", enterEditMode);
    display.addEventListener("dblclick", enterEditMode);
    saveBtn.addEventListener("click", saveValue);
    cancelBtn.addEventListener("click", exitEditMode);
    input.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        saveValue();
      } else if (e.key === "Escape") {
        exitEditMode();
      }
    });
    input.addEventListener("blur", (e) => {
      const relatedTarget = e.relatedTarget;
      if (relatedTarget !== saveBtn && relatedTarget !== cancelBtn) {
        setTimeout(() => {
          if (input.style.display !== "none") {
            exitEditMode();
          }
        }, 100);
      }
    });
  }
  /**
   * Render toolbar with zoom controls and refresh button
   */
  renderRefreshButton() {
    const toolbar = this.containerEl.createDiv({ cls: "hermine-toolbar" });
    if (this.config.yAxis) {
      const zoomControls = toolbar.createDiv({ cls: "hermine-zoom-controls" });
      const zoomOutBtn = zoomControls.createEl("button", { cls: "hermine-zoom-btn" });
      (0, import_obsidian3.setIcon)(zoomOutBtn, "minus");
      zoomOutBtn.title = "Verkleinern";
      zoomOutBtn.addEventListener("click", () => this.zoomOut());
      this.zoomDisplay = zoomControls.createEl("button", {
        cls: "hermine-zoom-display",
        text: `${this.zoomLevel}%`
      });
      this.zoomDisplay.title = "Zoom zur\xFCcksetzen";
      this.zoomDisplay.addEventListener("click", () => this.resetZoom());
      const zoomInBtn = zoomControls.createEl("button", { cls: "hermine-zoom-btn" });
      (0, import_obsidian3.setIcon)(zoomInBtn, "plus");
      zoomInBtn.title = "Vergr\xF6\xDFern";
      zoomInBtn.addEventListener("click", () => this.zoomIn());
      const slider = zoomControls.createEl("input", {
        cls: "hermine-zoom-slider",
        type: "range"
      });
      slider.min = String(_MatrixRenderer.ZOOM_MIN);
      slider.max = String(_MatrixRenderer.ZOOM_MAX);
      slider.step = String(_MatrixRenderer.ZOOM_STEP);
      slider.value = String(this.zoomLevel);
      slider.title = "Zoom";
      slider.addEventListener("input", (e) => {
        this.zoomLevel = parseInt(e.target.value);
        this.applyZoom();
      });
    }
    const refreshBtn = toolbar.createEl("button", {
      cls: "hermine-refresh-btn",
      text: "Aktualisieren"
    });
    (0, import_obsidian3.setIcon)(refreshBtn, "refresh-cw");
    refreshBtn.addEventListener("click", () => this.onRefresh());
  }
  /**
   * Zoom in by one step
   */
  zoomIn() {
    if (this.zoomLevel < _MatrixRenderer.ZOOM_MAX) {
      this.zoomLevel += _MatrixRenderer.ZOOM_STEP;
      this.applyZoom();
    }
  }
  /**
   * Zoom out by one step
   */
  zoomOut() {
    if (this.zoomLevel > _MatrixRenderer.ZOOM_MIN) {
      this.zoomLevel -= _MatrixRenderer.ZOOM_STEP;
      this.applyZoom();
    }
  }
  /**
   * Reset zoom to 100%
   */
  resetZoom() {
    this.zoomLevel = 100;
    this.applyZoom();
  }
  /**
   * Apply current zoom level to the board
   */
  applyZoom() {
    if (this.boardEl) {
      const scale = this.zoomLevel / 100;
      this.boardEl.style.transform = `scale(${scale})`;
      this.boardEl.style.transformOrigin = "top left";
    }
    if (this.zoomDisplay) {
      this.zoomDisplay.textContent = `${this.zoomLevel}%`;
    }
    const slider = this.containerEl.querySelector(".hermine-zoom-slider");
    if (slider) {
      slider.value = String(this.zoomLevel);
    }
  }
  /**
   * Get property value from object, supporting nested paths
   */
  getPropertyValue(obj, path) {
    const parts = path.split(".");
    let value = obj;
    for (const part of parts) {
      if (value === null || value === void 0) {
        return void 0;
      }
      value = value[part];
    }
    return value;
  }
  /**
   * Format a value for display
   */
  formatDisplayValue(value) {
    if (value === null || value === void 0) {
      return "";
    }
    if (Array.isArray(value)) {
      return value.join(", ");
    }
    if (typeof value === "object") {
      return JSON.stringify(value);
    }
    return String(value);
  }
};
var MatrixRenderer = _MatrixRenderer;
// Zoom settings
MatrixRenderer.ZOOM_MIN = 50;
MatrixRenderer.ZOOM_MAX = 150;
MatrixRenderer.ZOOM_STEP = 10;

// src/main.ts
var DEFAULT_SETTINGS = {
  refreshOnChange: true,
  defaultSort: "asc"
};
var HerminePlugin = class extends import_obsidian4.Plugin {
  async onload() {
    await this.loadSettings();
    this.queryEngine = new QueryEngine(this.app);
    this.registerMarkdownCodeBlockProcessor("hermine", this.processHermineBlock.bind(this));
    this.addSettingTab(new HermineSettingTab(this.app, this));
    console.log("Hermine plugin loaded");
  }
  onunload() {
    console.log("Hermine plugin unloaded");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  /**
   * Process a hermine code block
   */
  async processHermineBlock(source, el, ctx) {
    try {
      const config = parseHermineBlock(source);
      if (!config.sort) {
        config.sort = {
          by: config.xAxis,
          order: this.settings.defaultSort
        };
      }
      const result = await this.queryEngine.execute(config);
      const refresh = async () => {
        const newResult = await this.queryEngine.execute(config);
        el.empty();
        const renderer2 = new MatrixRenderer(el, this.app, config, newResult, refresh);
        ctx.addChild(renderer2);
      };
      const renderer = new MatrixRenderer(el, this.app, config, result, refresh);
      ctx.addChild(renderer);
    } catch (error) {
      el.createDiv({
        cls: "hermine-error",
        text: `Hermine Error: ${error.message}`
      });
    }
  }
};
var HermineSettingTab = class extends import_obsidian4.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Hermine Einstellungen" });
    new import_obsidian4.Setting(containerEl).setName("Automatisch aktualisieren").setDesc("Aktualisiert die Ansicht automatisch, wenn Dokumente ge\xE4ndert werden").addToggle((toggle) => toggle.setValue(this.plugin.settings.refreshOnChange).onChange(async (value) => {
      this.plugin.settings.refreshOnChange = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(containerEl).setName("Standard-Sortierung").setDesc("Standard-Sortierrichtung f\xFCr Abfragen").addDropdown((dropdown) => dropdown.addOption("asc", "Aufsteigend").addOption("desc", "Absteigend").setValue(this.plugin.settings.defaultSort).onChange(async (value) => {
      this.plugin.settings.defaultSort = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Verwendung" });
    const usageEl = containerEl.createDiv({ cls: "hermine-settings-usage" });
    usageEl.innerHTML = `
      <p>Erstellen Sie einen Code-Block mit dem Typ <code>hermine</code>:</p>
      <pre><code>\`\`\`hermine
source: "Projekte"
x-achse: Status
y-achse: Priorit\xE4t
display: Deadline, Verantwortlich
sort: Status asc
where: Status != "Abgeschlossen"
\`\`\`</code></pre>

      <h4>Konfigurationsoptionen:</h4>
      <ul>
        <li><strong>source / from / quelle</strong>: Quelle der Dokumente
          <ul>
            <li><code>"Ordnername"</code> - Dokumente aus einem Ordner</li>
            <li><code>#tag</code> - Dokumente mit einem bestimmten Tag</li>
            <li><code>all</code> oder <code>*</code> - Alle Dokumente</li>
          </ul>
        </li>
        <li><strong>x-achse / x / xaxis</strong>: Eigenschaft f\xFCr die X-Achse (Pflicht)</li>
        <li><strong>y-achse / y / yaxis</strong>: Eigenschaft f\xFCr die Y-Achse (Optional, erstellt Matrix-Ansicht)</li>
        <li><strong>display / anzeigen / show</strong>: Zus\xE4tzliche Eigenschaften zum Anzeigen (kommagetrennt)</li>
        <li><strong>sort / sortieren</strong>: Sortierung (<code>Eigenschaft asc/desc</code>)</li>
        <li><strong>where / filter</strong>: Filterbedingung</li>
      </ul>

      <h4>Filter-Syntax:</h4>
      <ul>
        <li><code>Eigenschaft = "Wert"</code></li>
        <li><code>Eigenschaft != "Wert"</code></li>
        <li><code>Eigenschaft contains "Teilwert"</code></li>
      </ul>
    `;
  }
};
